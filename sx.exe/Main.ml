open Bos

let ( let* ) = Result.bind

module String_set = Set.Make (String)

let rev_lines_of_chann chan =
  let rec loop acc chan =
    match input_line chan with
    | line -> loop (line :: acc) chan
    | exception End_of_file ->
      close_in chan;
      acc
  in
  loop [] chan


let ensure_is_rescript_root () =
  if not (OS.File.exists (Fpath.v "bsconfig.json") |> Result.get_ok) then
    failwith
      "sx: Could not find bsconfig.json file in the current directory. Is this \
       a ReScript project?"


let rescript_toplevel_modules =
  lazy
    (let mlmap_pat = Fpath.v "./lib/bs/$(namespace).mlmap" in
     match OS.Path.matches mlmap_pat with
     | Ok [ sourcefile ] ->
       (* https://github.com/rescript-lang/rescript-compiler/blob/b4d5caea15e9594f95f6f8ac6620417540986c20/jscomp/core/js_implementation.ml#L254 *)
       let ext_digest_length = 16 in
       let ichan = open_in_bin (Fpath.to_string sourcefile) in
       seek_in ichan (ext_digest_length + 1);
       let list_of_modules = rev_lines_of_chann ichan in
       close_in ichan;
       list_of_modules |> String_set.of_list
     | Error (`Msg msg) ->
       prerr_endline
         ("sx: error: could not find .mlmap file in ./lib/bs:\n" ^ msg);
       exit 1
     | Ok [] ->
       prerr_endline
         "sx: error: No .mlmap file found in ./lib/bs.\n\
          Is your project compiled and has namespacing enabled?";
       exit 1
     | _ ->
       prerr_endline
         "sx: error: More than one .mlmap file found in ./lib/bs.\n\
          Try cleanning and rebuilding your project.";
       exit 1)


let main output_file =
  ensure_is_rescript_root ();
  let sx_cache_files_pat =
    Fpath.v "./node_modules/.cache/sx/$(module_name).mldata"
  in
  let* paths = OS.Path.matches sx_cache_files_pat in
  let css =
    List.fold_left
      (fun acc cache_file ->
        let cache_file_basename =
          cache_file |> Fpath.rem_ext ~multi:true |> Fpath.basename
        in
        if
          String_set.exists
            (String.equal cache_file_basename)
            (Lazy.force rescript_toplevel_modules)
        then (
          prerr_endline
            ("sx: Combining css for module " ^ Fpath.to_string cache_file);
          let css = Sx.read_module_cache cache_file in
          Sx.Css.union acc css)
        else (
          prerr_endline
            ("sx: Deleting a stale cache file: " ^ Fpath.to_string cache_file);
          OS.File.delete cache_file |> Result.get_ok;
          acc))
      Sx.Css.empty paths
  in
  let chan = open_out_bin (Fpath.to_string output_file) in
  Fmt.pf
    (Format.formatter_of_out_channel chan)
    "@[<v>/* Generated by sx, PLEASE DO NOT EDIT! */@,@,%a@]@." Sx.Css.pp css;
  Ok ()


let () =
  match Sys.argv with
  | [| _; "-o"; output_file |] -> main (Fpath.v output_file) |> Result.get_ok
  | _ ->
    prerr_endline "sx: error: missing required -o option";
    exit 1
